'''
'행렬'
문제 : 0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.
행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)

입력 : 첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 
그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.

출력 : 첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.

풀이 : 1. 3*3 행렬을 뒤집는 함수를 생성한다.
    2. 함수는 지정한 인덱스에서 3*3행렬만큼 뒤집을 수 있는 경우에만 수행한다.
    3. for문을 돌며 A행렬과 B행렬이 다른 인덱스가 있을 경우 함수를 수행한다.
    4. 모든 연산을 끝낸 후에도 A행렬과 B행렬이 다를 경우에는 -1, 같을 경우는 연산횟수를 출력한다.

comment : 처음에는 '어디부터 먼저 연산을 수행해야 횟수가 최소가 되지' 라는 생각에 고민이 많았다. 감을 못잡겠어서 어떤 알고리즘을 사용해야 하는지
봤는데, 그리디 알고리즘이었다. 만약 그리디 알고리즘이라는 것을 몰랐다면 많이 고생했을 것이다.
사실 그리디로 다 풀고나서도 이게 왜 그리디로 풀었을 때 최적의 해가 나오는지 이해가 잘 가지 않아서 블로그를 많이 찾아봤다.
찾아본 결과, 정리하면 다음과 같다.
문제의 목적은 A행렬에서 B행렬로 바꾸는 것이므로 다른 칸이 있으면 무조건 뒤집어야 한다. 하지만 뒤집는 특성상 2번, 3번 뒤집는 것은 의미가 없다.
따라서 행렬을 순서대로 진행하면서 다른 부분이 있으면 뒤집어주는 것이다.
그리디가 어떨 때 이용되는지 깨닫게됐다.
'''
n, m = map(int, input().split())
A = []
B = []
for i in range(n):
    A.append(list(input()))
for i in range(n):
    B.append(list(input()))

def change(x, y):               # 3*3 행렬 뒤집는 연산 함수
    # 지정한 인덱스의 3*3 행렬이 범위를 넘지 않을 경우에 for문 돌기
    if x < n and x+1 < n and x+2 < n and y < m and y+1 < m and y+2 < m:
        for i in range(x, x+3):
            for j in range(y, y+3):
                if A[i][j] == '1':
                    A[i][j] = '0'
                else:
                    A[i][j] = '1'

cnt = 0
for i in range(n):
    for j in range(m):
        if A[i][j] != B[i][j]:  # A와 B가 다를 경우 함수 실행(그리디)
            change(i, j)
            cnt += 1

isEqual = True
for i in range(n):              # 모든 연산 완료 후 A행렬과 B행렬 비교
    for j in range(m):
        if A[i][j] != B[i][j]:
            isEqual = False
if isEqual:                     # 같으면 연산횟수, 다르면 -1 출력
    print(cnt)
else:
    print(-1)
